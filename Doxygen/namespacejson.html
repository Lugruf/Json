<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Json: json Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Json
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">C++ API for parsing and writing json files.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacejson.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">json Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacejson_1_1mpl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson_1_1mpl.html">mpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacejson_1_1parser"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson_1_1parser.html">parser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacejson_1_1string__key__literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson_1_1string__key__literals.html">string_key_literals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacejson_1_1writer"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson_1_1writer.html">writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjson_1_1basic__static__string.html">basic_static_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a constant string that will outlive the <a class="el" href="classjson_1_1value.html" title="Data structure representing a json value http://www.json.org. ">json::value</a> that is using it (usually a string literal). A <a class="el" href="classjson_1_1value.html" title="Data structure representing a json value http://www.json.org. ">json::value</a> can use static strings as keys for objects in order to avoid allocations if the user knows for sure that the string will not be destroyed while the value is being used.  <a href="classjson_1_1basic__static__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a string key for an associative container. It's used as the key of the map in <a class="el" href="classjson_1_1object.html" title="Data structure representing json object. An object is an unordered set of name/value pairs...">json::object</a>. Supports standard traits and allocators, as well as transparent comparison with c strings and std::basic_strings. If constructed from a static_string, the class will keep a reference to the original string instead of allocating a copy, acting as an string_view, thus saving a heap operation if the user is sure that the static string will outlive the string_key. The string is immutable. After being constructed, it can't be mutated in any way.  <a href="classjson_1_1basic__string__key.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjson_1_1invalid__operation.html">invalid_operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when trying to access a value as a type different to its own (eg: using as_int on an array type) or when comparing for inequality two values of different types.  <a href="classjson_1_1invalid__operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjson_1_1object.html">object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure representing json object. An object is an unordered set of name/value pairs. An object begins with { (left brace) and ends with } (right brace). Each name is followed by : (colon) and the name/value pairs are separated by , (comma). <a href="http://www.json.org/">http://www.json.org/</a>.  <a href="classjson_1_1object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjson_1_1value.html">value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure representing a json value <a href="http://www.json.org">http://www.json.org</a>.  <a href="classjson_1_1value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae81c666a2862b007cb033895d0721214"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae81c666a2862b007cb033895d0721214"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#ae81c666a2862b007cb033895d0721214">allocator</a> = std::allocator&lt; T &gt;</td></tr>
<tr class="memdesc:ae81c666a2862b007cb033895d0721214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator type used by all the json functions and classes.  <a href="#ae81c666a2862b007cb033895d0721214">More...</a><br /></td></tr>
<tr class="separator:ae81c666a2862b007cb033895d0721214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4c6d89490ba96079af5596ed4743df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#adf4c6d89490ba96079af5596ed4743df">string</a> = std::basic_string&lt; char, std::char_traits&lt; char &gt;, <a class="el" href="namespacejson.html#ae81c666a2862b007cb033895d0721214">json::allocator</a>&lt; char &gt; &gt;</td></tr>
<tr class="memdesc:adf4c6d89490ba96079af5596ed4743df"><td class="mdescLeft">&#160;</td><td class="mdescRight">String type used by all the json functions and classes.  <a href="#adf4c6d89490ba96079af5596ed4743df">More...</a><br /></td></tr>
<tr class="separator:adf4c6d89490ba96079af5596ed4743df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0da1c79d774841b51e0ad191790344a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0da1c79d774841b51e0ad191790344a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#ae0da1c79d774841b51e0ad191790344a">vector</a> = std::vector&lt; T, <a class="el" href="namespacejson.html#ae81c666a2862b007cb033895d0721214">json::allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ae0da1c79d774841b51e0ad191790344a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type used by all the json functions and classes.  <a href="#ae0da1c79d774841b51e0ad191790344a">More...</a><br /></td></tr>
<tr class="separator:ae0da1c79d774841b51e0ad191790344a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab931fa31dfdad8e9114055d000770e"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:aaab931fa31dfdad8e9114055d000770e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#aaab931fa31dfdad8e9114055d000770e">map</a> = std::map&lt; Key, Value, std::less&lt;&gt;, <a class="el" href="namespacejson.html#ae81c666a2862b007cb033895d0721214">json::allocator</a>&lt; std::pair&lt; const Key, Value &gt; &gt;&gt;</td></tr>
<tr class="memdesc:aaab931fa31dfdad8e9114055d000770e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map type used by all the json functions and classes.  <a href="#aaab931fa31dfdad8e9114055d000770e">More...</a><br /></td></tr>
<tr class="separator:aaab931fa31dfdad8e9114055d000770e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df9ca4e1624ff4202d4052879321a09"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#a3df9ca4e1624ff4202d4052879321a09">static_string</a> = <a class="el" href="classjson_1_1basic__static__string.html">basic_static_string</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a3df9ca4e1624ff4202d4052879321a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="classjson_1_1basic__static__string.html" title="Representation of a constant string that will outlive the json::value that is using it (usually a str...">basic_static_string</a> of chars (the same way <a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaab45cffe084dd3d20d928bee85e7b0f21">std::string</a> is std::basic_string&lt;char&gt;)  <a href="#a3df9ca4e1624ff4202d4052879321a09">More...</a><br /></td></tr>
<tr class="separator:a3df9ca4e1624ff4202d4052879321a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0a239c7b818e7263c9db362d5663a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#a0f0a239c7b818e7263c9db362d5663a4">static_wstring</a> = <a class="el" href="classjson_1_1basic__static__string.html">basic_static_string</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:a0f0a239c7b818e7263c9db362d5663a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="classjson_1_1basic__static__string.html" title="Representation of a constant string that will outlive the json::value that is using it (usually a str...">basic_static_string</a> of wchar_t.  <a href="#a0f0a239c7b818e7263c9db362d5663a4">More...</a><br /></td></tr>
<tr class="separator:a0f0a239c7b818e7263c9db362d5663a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317b6b1634fb6f8cd00cb0f8c1332697"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#a317b6b1634fb6f8cd00cb0f8c1332697">static_u16string</a> = <a class="el" href="classjson_1_1basic__static__string.html">basic_static_string</a>&lt; char16_t &gt;</td></tr>
<tr class="memdesc:a317b6b1634fb6f8cd00cb0f8c1332697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="classjson_1_1basic__static__string.html" title="Representation of a constant string that will outlive the json::value that is using it (usually a str...">basic_static_string</a> of char16_t.  <a href="#a317b6b1634fb6f8cd00cb0f8c1332697">More...</a><br /></td></tr>
<tr class="separator:a317b6b1634fb6f8cd00cb0f8c1332697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33814f8711ad3af4579e5edffb55053"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#ab33814f8711ad3af4579e5edffb55053">static_u32string</a> = <a class="el" href="classjson_1_1basic__static__string.html">basic_static_string</a>&lt; char32_t &gt;</td></tr>
<tr class="memdesc:ab33814f8711ad3af4579e5edffb55053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="classjson_1_1basic__static__string.html" title="Representation of a constant string that will outlive the json::value that is using it (usually a str...">basic_static_string</a> of char32_t.  <a href="#ab33814f8711ad3af4579e5edffb55053">More...</a><br /></td></tr>
<tr class="separator:ab33814f8711ad3af4579e5edffb55053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5131b268f0de7a671e4b7a9129f63faf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#a5131b268f0de7a671e4b7a9129f63faf">string_key</a> = <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; char &gt;</td></tr>
<tr class="memdesc:a5131b268f0de7a671e4b7a9129f63faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="classjson_1_1basic__string__key.html" title="Representation of a string key for an associative container. It&#39;s used as the key of the map in json:...">basic_string_key</a> of chars (the same way <a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaab45cffe084dd3d20d928bee85e7b0f21">std::string</a> is std::basic_string&lt;char&gt;)  <a href="#a5131b268f0de7a671e4b7a9129f63faf">More...</a><br /></td></tr>
<tr class="separator:a5131b268f0de7a671e4b7a9129f63faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a4399831ee43095ae3fac2a63acf57"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#a99a4399831ee43095ae3fac2a63acf57">wstring_key</a> = <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; wchar_t &gt;</td></tr>
<tr class="memdesc:a99a4399831ee43095ae3fac2a63acf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="classjson_1_1basic__string__key.html" title="Representation of a string key for an associative container. It&#39;s used as the key of the map in json:...">basic_string_key</a> of wchar_t.  <a href="#a99a4399831ee43095ae3fac2a63acf57">More...</a><br /></td></tr>
<tr class="separator:a99a4399831ee43095ae3fac2a63acf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257983dc753e4e1d0420e71f8b1eab6d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#a257983dc753e4e1d0420e71f8b1eab6d">u16string_key</a> = <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; char16_t &gt;</td></tr>
<tr class="memdesc:a257983dc753e4e1d0420e71f8b1eab6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="classjson_1_1basic__string__key.html" title="Representation of a string key for an associative container. It&#39;s used as the key of the map in json:...">basic_string_key</a> of char16_t.  <a href="#a257983dc753e4e1d0420e71f8b1eab6d">More...</a><br /></td></tr>
<tr class="separator:a257983dc753e4e1d0420e71f8b1eab6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea32442a404e94eb5a2ecc3c3b14a35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#a0ea32442a404e94eb5a2ecc3c3b14a35">u32string_key</a> = <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; char32_t &gt;</td></tr>
<tr class="memdesc:a0ea32442a404e94eb5a2ecc3c3b14a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for <a class="el" href="classjson_1_1basic__string__key.html" title="Representation of a string key for an associative container. It&#39;s used as the key of the map in json:...">basic_string_key</a> of char32_t.  <a href="#a0ea32442a404e94eb5a2ecc3c3b14a35">More...</a><br /></td></tr>
<tr class="separator:a0ea32442a404e94eb5a2ecc3c3b14a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe1e90763ce6266cb4279fcb4264941"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#acbe1e90763ce6266cb4279fcb4264941">array</a> = <a class="el" href="namespacejson.html#ae0da1c79d774841b51e0ad191790344a">json::vector</a>&lt; <a class="el" href="classjson_1_1value.html">json::value</a> &gt;</td></tr>
<tr class="memdesc:acbe1e90763ce6266cb4279fcb4264941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure representing a json array. An array is an ordered collection of values. An array begins with [ (left bracket) and ends with ] (right bracket). Values are separated by , (comma). <a href="http://www.json.org/">http://www.json.org/</a>.  <a href="#acbe1e90763ce6266cb4279fcb4264941">More...</a><br /></td></tr>
<tr class="separator:acbe1e90763ce6266cb4279fcb4264941"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a42adda0909e4b5681dad640f482f98ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98ea">value_type</a> { <br />
&#160;&#160;<a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaa37a6259cc0c1dae299a7866489dff0bd">value_type::null</a> = 0, 
<a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaa157db7df530023575515d366c9b672e8">value_type::integer</a> = 1, 
<a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaa4bca24304861acde5770fdbe3cc2503b">value_type::real</a> = 2, 
<a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaa84e2c64f38f78ba3ea5c905ab5a2da27">value_type::boolean</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaab45cffe084dd3d20d928bee85e7b0f21">value_type::string</a> = 4, 
<a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaaf1f713c9e000f5d3f280adbd124df4f5">value_type::array</a> = 5, 
<a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaaa8cfde6331bd59eb2ac96f8911c4b666">value_type::object</a> = 6
<br />
 }<tr class="memdesc:a42adda0909e4b5681dad640f482f98ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum with the possible types a <a class="el" href="classjson_1_1value.html" title="Data structure representing a json value http://www.json.org. ">json::value</a> may hold.  <a href="namespacejson.html#a42adda0909e4b5681dad640f482f98ea">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a42adda0909e4b5681dad640f482f98ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a64bee7abec3a3b5ded49861e3a46068f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64bee7abec3a3b5ded49861e3a46068f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a64bee7abec3a3b5ded49861e3a46068f">points_inside</a> (const void *p, const T &amp;obj)</td></tr>
<tr class="memdesc:a64bee7abec3a3b5ded49861e3a46068f"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if p points to obj or a member of obj True if p points to an address in memory in the range [&amp;obj, (char *)&amp;obj + sizeof(obj))  <a href="#a64bee7abec3a3b5ded49861e3a46068f">More...</a><br /></td></tr>
<tr class="separator:a64bee7abec3a3b5ded49861e3a46068f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af777b441b49549f3157150542652538c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:af777b441b49549f3157150542652538c"><td class="memTemplItemLeft" align="right" valign="top">CharT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#af777b441b49549f3157150542652538c">release</a> (std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;s)</td></tr>
<tr class="memdesc:af777b441b49549f3157150542652538c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a string release the ownership over its dynamic memory and return a pointer to it.  <a href="#af777b441b49549f3157150542652538c">More...</a><br /></td></tr>
<tr class="separator:af777b441b49549f3157150542652538c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b35a1fdf1bfab72ba0fda7426be30a"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:af8b35a1fdf1bfab72ba0fda7426be30a"><td class="memTemplItemLeft" align="right" valign="top">CharT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#af8b35a1fdf1bfab72ba0fda7426be30a">release</a> (std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp;s)</td></tr>
<tr class="memdesc:af8b35a1fdf1bfab72ba0fda7426be30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a string release the ownership over its dynamic memory and return a pointer to it.  <a href="#af8b35a1fdf1bfab72ba0fda7426be30a">More...</a><br /></td></tr>
<tr class="separator:af8b35a1fdf1bfab72ba0fda7426be30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4e742101a86b07cf0cd06570a8a3df"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:abb4e742101a86b07cf0cd06570a8a3df"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#abb4e742101a86b07cf0cd06570a8a3df">release</a> (std::vector&lt; T, Allocator &gt; &amp;v)</td></tr>
<tr class="memdesc:abb4e742101a86b07cf0cd06570a8a3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a vector release the ownership over its dynamic memory and return a pointer to it.  <a href="#abb4e742101a86b07cf0cd06570a8a3df">More...</a><br /></td></tr>
<tr class="separator:abb4e742101a86b07cf0cd06570a8a3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed064e51967e385b995309e2b1e7dbf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a4ed064e51967e385b995309e2b1e7dbf"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a4ed064e51967e385b995309e2b1e7dbf">release</a> (std::vector&lt; T, Allocator &gt; &amp;&amp;v)</td></tr>
<tr class="memdesc:a4ed064e51967e385b995309e2b1e7dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a vector release the ownership over its dynamic memory and return a pointer to it.  <a href="#a4ed064e51967e385b995309e2b1e7dbf">More...</a><br /></td></tr>
<tr class="separator:a4ed064e51967e385b995309e2b1e7dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a78b4c5e0c268070e8572e13e045a0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Deleter &gt; </td></tr>
<tr class="memitem:a35a78b4c5e0c268070e8572e13e045a0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T, Deleter &gt;::pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a35a78b4c5e0c268070e8572e13e045a0">release</a> (std::unique_ptr&lt; T, Deleter &gt; &amp;p)</td></tr>
<tr class="memdesc:a35a78b4c5e0c268070e8572e13e045a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a unique_ptr release the ownership over its dynamic memory. Same as <a class="el" href="namespacejson.html#a30c670fcc57b21f3b9485ec457145015" title="Makes a unique_ptr release the ownership over its dynamic memory. Same as p.release() ...">p.release()</a>  <a href="#a35a78b4c5e0c268070e8572e13e045a0">More...</a><br /></td></tr>
<tr class="separator:a35a78b4c5e0c268070e8572e13e045a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c670fcc57b21f3b9485ec457145015"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Deleter &gt; </td></tr>
<tr class="memitem:a30c670fcc57b21f3b9485ec457145015"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T, Deleter &gt;::pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a30c670fcc57b21f3b9485ec457145015">release</a> (std::unique_ptr&lt; T, Deleter &gt; &amp;&amp;p)</td></tr>
<tr class="memdesc:a30c670fcc57b21f3b9485ec457145015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a unique_ptr release the ownership over its dynamic memory. Same as <a class="el" href="namespacejson.html#a30c670fcc57b21f3b9485ec457145015" title="Makes a unique_ptr release the ownership over its dynamic memory. Same as p.release() ...">p.release()</a>  <a href="#a30c670fcc57b21f3b9485ec457145015">More...</a><br /></td></tr>
<tr class="separator:a30c670fcc57b21f3b9485ec457145015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d76be8d5ff3eca25168c0c80b77ad03"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:a8d76be8d5ff3eca25168c0c80b77ad03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a8d76be8d5ff3eca25168c0c80b77ad03">operator==</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a8d76be8d5ff3eca25168c0c80b77ad03"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if both strings are equal.  <a href="#a8d76be8d5ff3eca25168c0c80b77ad03">More...</a><br /></td></tr>
<tr class="separator:a8d76be8d5ff3eca25168c0c80b77ad03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2633134121d6757c7ba829d4b2623b43"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:a2633134121d6757c7ba829d4b2623b43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a2633134121d6757c7ba829d4b2623b43">operator!=</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a2633134121d6757c7ba829d4b2623b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if both strings are not equal.  <a href="#a2633134121d6757c7ba829d4b2623b43">More...</a><br /></td></tr>
<tr class="separator:a2633134121d6757c7ba829d4b2623b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca8b4fedc32245aa40ddb63e20e5a34"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:a5ca8b4fedc32245aa40ddb63e20e5a34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a5ca8b4fedc32245aa40ddb63e20e5a34">operator&lt;</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a5ca8b4fedc32245aa40ddb63e20e5a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares both strings.  <a href="#a5ca8b4fedc32245aa40ddb63e20e5a34">More...</a><br /></td></tr>
<tr class="separator:a5ca8b4fedc32245aa40ddb63e20e5a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eace896f7bad716840927c3c6c76d23"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:a4eace896f7bad716840927c3c6c76d23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a4eace896f7bad716840927c3c6c76d23">operator&lt;=</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a4eace896f7bad716840927c3c6c76d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares both strings.  <a href="#a4eace896f7bad716840927c3c6c76d23">More...</a><br /></td></tr>
<tr class="separator:a4eace896f7bad716840927c3c6c76d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85acab7e94d58880b8b93342dc7cea08"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:a85acab7e94d58880b8b93342dc7cea08"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a85acab7e94d58880b8b93342dc7cea08">operator&gt;</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:a85acab7e94d58880b8b93342dc7cea08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares both strings.  <a href="#a85acab7e94d58880b8b93342dc7cea08">More...</a><br /></td></tr>
<tr class="separator:a85acab7e94d58880b8b93342dc7cea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e232e405cf1f26a8ba37698cda3f4c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:ad4e232e405cf1f26a8ba37698cda3f4c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#ad4e232e405cf1f26a8ba37698cda3f4c">operator&gt;=</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ad4e232e405cf1f26a8ba37698cda3f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographically compares both strings.  <a href="#ad4e232e405cf1f26a8ba37698cda3f4c">More...</a><br /></td></tr>
<tr class="separator:ad4e232e405cf1f26a8ba37698cda3f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2649256bf1d9fb6c15800d4bc70ec70"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:aa2649256bf1d9fb6c15800d4bc70ec70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#aa2649256bf1d9fb6c15800d4bc70ec70">operator==</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;a, const CharT *b) noexcept</td></tr>
<tr class="memdesc:aa2649256bf1d9fb6c15800d4bc70ec70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of comparison operators for c strings.  <a href="#aa2649256bf1d9fb6c15800d4bc70ec70">More...</a><br /></td></tr>
<tr class="separator:aa2649256bf1d9fb6c15800d4bc70ec70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce7c064492af9cac758a7b493eea711"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a9ce7c064492af9cac758a7b493eea711"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a9ce7c064492af9cac758a7b493eea711">operator!=</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;a, const CharT *b) noexcept</td></tr>
<tr class="separator:a9ce7c064492af9cac758a7b493eea711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466e771d6fe0fbaa01450e34d1a0edab"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a466e771d6fe0fbaa01450e34d1a0edab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a466e771d6fe0fbaa01450e34d1a0edab">operator&lt;</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;a, const CharT *b) noexcept</td></tr>
<tr class="separator:a466e771d6fe0fbaa01450e34d1a0edab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80aa45d78dfbb09edff5be7544550df"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ad80aa45d78dfbb09edff5be7544550df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#ad80aa45d78dfbb09edff5be7544550df">operator&lt;=</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;a, const CharT *b) noexcept</td></tr>
<tr class="separator:ad80aa45d78dfbb09edff5be7544550df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae7459a31f1dfc064e9edbbf01b3db8"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:acae7459a31f1dfc064e9edbbf01b3db8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#acae7459a31f1dfc064e9edbbf01b3db8">operator&gt;</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;a, const CharT *b) noexcept</td></tr>
<tr class="separator:acae7459a31f1dfc064e9edbbf01b3db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca8111d03505de4687d691e75b8b754"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a0ca8111d03505de4687d691e75b8b754"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a0ca8111d03505de4687d691e75b8b754">operator&gt;=</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;a, const CharT *b) noexcept</td></tr>
<tr class="separator:a0ca8111d03505de4687d691e75b8b754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d637420ca495ad7661d973b3515a345"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a0d637420ca495ad7661d973b3515a345"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a0d637420ca495ad7661d973b3515a345">operator==</a> (const CharT *a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a0d637420ca495ad7661d973b3515a345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8376ba97b28317b7c55fde338ba802"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a5a8376ba97b28317b7c55fde338ba802"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a5a8376ba97b28317b7c55fde338ba802">operator!=</a> (const CharT *a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a5a8376ba97b28317b7c55fde338ba802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba51123a1e95f22ab8de9e7196a9d86"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a1ba51123a1e95f22ab8de9e7196a9d86"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a1ba51123a1e95f22ab8de9e7196a9d86">operator&lt;</a> (const CharT *a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a1ba51123a1e95f22ab8de9e7196a9d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f064054b9f2e109ae5e0c99215b1518"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a8f064054b9f2e109ae5e0c99215b1518"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a8f064054b9f2e109ae5e0c99215b1518">operator&lt;=</a> (const CharT *a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a8f064054b9f2e109ae5e0c99215b1518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1514e7cdc5f84060c9c6f161eea38589"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:a1514e7cdc5f84060c9c6f161eea38589"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a1514e7cdc5f84060c9c6f161eea38589">operator&gt;</a> (const CharT *a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a1514e7cdc5f84060c9c6f161eea38589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af011bccfee7064acd948b61ecc40ed73"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:af011bccfee7064acd948b61ecc40ed73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#af011bccfee7064acd948b61ecc40ed73">operator&gt;=</a> (const CharT *a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;b) noexcept</td></tr>
<tr class="separator:af011bccfee7064acd948b61ecc40ed73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7dc6e54278d38c70f88af57472c439"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:abc7dc6e54278d38c70f88af57472c439"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#abc7dc6e54278d38c70f88af57472c439">operator==</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:abc7dc6e54278d38c70f88af57472c439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of comparison operators for std::basic_string.  <a href="#abc7dc6e54278d38c70f88af57472c439">More...</a><br /></td></tr>
<tr class="separator:abc7dc6e54278d38c70f88af57472c439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77baf8a3530de0b7aa88fe4d7b31b39"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:af77baf8a3530de0b7aa88fe4d7b31b39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#af77baf8a3530de0b7aa88fe4d7b31b39">operator!=</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:af77baf8a3530de0b7aa88fe4d7b31b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8cbdc279c81e2703c384e4027246c2"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:a9c8cbdc279c81e2703c384e4027246c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a9c8cbdc279c81e2703c384e4027246c2">operator&lt;</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a9c8cbdc279c81e2703c384e4027246c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff47dec3ac734cbb37548155dce267c"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:acff47dec3ac734cbb37548155dce267c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#acff47dec3ac734cbb37548155dce267c">operator&lt;=</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:acff47dec3ac734cbb37548155dce267c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67c871179bd20bb8eb2290567f2b9c3"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:ab67c871179bd20bb8eb2290567f2b9c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#ab67c871179bd20bb8eb2290567f2b9c3">operator&gt;</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:ab67c871179bd20bb8eb2290567f2b9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233436646f22bd9bb8a70b5e37d58b97"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:a233436646f22bd9bb8a70b5e37d58b97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a233436646f22bd9bb8a70b5e37d58b97">operator&gt;=</a> (const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;a, const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a233436646f22bd9bb8a70b5e37d58b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8ff35f7fadeee31d3a62608f0fa44e"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:acd8ff35f7fadeee31d3a62608f0fa44e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#acd8ff35f7fadeee31d3a62608f0fa44e">operator==</a> (const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:acd8ff35f7fadeee31d3a62608f0fa44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdafdbde7267785081cb94d7a91857be"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:acdafdbde7267785081cb94d7a91857be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#acdafdbde7267785081cb94d7a91857be">operator!=</a> (const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:acdafdbde7267785081cb94d7a91857be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7069cd34d18e1a2d66571ce407d86326"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:a7069cd34d18e1a2d66571ce407d86326"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#a7069cd34d18e1a2d66571ce407d86326">operator&lt;</a> (const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a7069cd34d18e1a2d66571ce407d86326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1de63055a07d84c227f7b2867ae8390"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:af1de63055a07d84c227f7b2867ae8390"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#af1de63055a07d84c227f7b2867ae8390">operator&lt;=</a> (const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:af1de63055a07d84c227f7b2867ae8390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad671d5552c5993ae220e264c32bf51"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:afad671d5552c5993ae220e264c32bf51"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#afad671d5552c5993ae220e264c32bf51">operator&gt;</a> (const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:afad671d5552c5993ae220e264c32bf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76dbb40389e2ed716138a0d95a65d47"><td class="memTemplParams" colspan="2">template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </td></tr>
<tr class="memitem:af76dbb40389e2ed716138a0d95a65d47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejson.html#af76dbb40389e2ed716138a0d95a65d47">operator&gt;=</a> (const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;a, const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:af76dbb40389e2ed716138a0d95a65d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae81c666a2862b007cb033895d0721214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81c666a2862b007cb033895d0721214">&#9670;&nbsp;</a></span>allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#ae81c666a2862b007cb033895d0721214">json::allocator</a> = typedef std::allocator&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocator type used by all the json functions and classes. </p>

<p class="definition">Definition at line <a class="el" href="config_8hh_source.html#l00015">15</a> of file <a class="el" href="config_8hh_source.html">config.hh</a>.</p>

</div>
</div>
<a id="acbe1e90763ce6266cb4279fcb4264941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe1e90763ce6266cb4279fcb4264941">&#9670;&nbsp;</a></span>array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#acbe1e90763ce6266cb4279fcb4264941">json::array</a> = typedef <a class="el" href="namespacejson.html#ae0da1c79d774841b51e0ad191790344a">json::vector</a>&lt;<a class="el" href="classjson_1_1value.html">json::value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data structure representing a json array. An array is an ordered collection of values. An array begins with [ (left bracket) and ends with ] (right bracket). Values are separated by , (comma). <a href="http://www.json.org/">http://www.json.org/</a>. </p>

<p class="definition">Definition at line <a class="el" href="value_8hh_source.html#l00039">39</a> of file <a class="el" href="value_8hh_source.html">value.hh</a>.</p>

</div>
</div>
<a id="aaab931fa31dfdad8e9114055d000770e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab931fa31dfdad8e9114055d000770e">&#9670;&nbsp;</a></span>map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#aaab931fa31dfdad8e9114055d000770e">json::map</a> = typedef std::map&lt;Key, Value, std::less&lt;&gt;, <a class="el" href="namespacejson.html#ae81c666a2862b007cb033895d0721214">json::allocator</a>&lt;std::pair&lt;const Key, Value&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map type used by all the json functions and classes. </p>

<p class="definition">Definition at line <a class="el" href="config_8hh_source.html#l00026">26</a> of file <a class="el" href="config_8hh_source.html">config.hh</a>.</p>

</div>
</div>
<a id="a3df9ca4e1624ff4202d4052879321a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df9ca4e1624ff4202d4052879321a09">&#9670;&nbsp;</a></span>static_string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#a3df9ca4e1624ff4202d4052879321a09">json::static_string</a> = typedef <a class="el" href="classjson_1_1basic__static__string.html">basic_static_string</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for <a class="el" href="classjson_1_1basic__static__string.html" title="Representation of a constant string that will outlive the json::value that is using it (usually a str...">basic_static_string</a> of chars (the same way <a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaab45cffe084dd3d20d928bee85e7b0f21">std::string</a> is std::basic_string&lt;char&gt;) </p>

<p class="definition">Definition at line <a class="el" href="string__key_8hh_source.html#l00039">39</a> of file <a class="el" href="string__key_8hh_source.html">string_key.hh</a>.</p>

</div>
</div>
<a id="a317b6b1634fb6f8cd00cb0f8c1332697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317b6b1634fb6f8cd00cb0f8c1332697">&#9670;&nbsp;</a></span>static_u16string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#a317b6b1634fb6f8cd00cb0f8c1332697">json::static_u16string</a> = typedef <a class="el" href="classjson_1_1basic__static__string.html">basic_static_string</a>&lt;char16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for <a class="el" href="classjson_1_1basic__static__string.html" title="Representation of a constant string that will outlive the json::value that is using it (usually a str...">basic_static_string</a> of char16_t. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8hh_source.html#l00043">43</a> of file <a class="el" href="string__key_8hh_source.html">string_key.hh</a>.</p>

</div>
</div>
<a id="ab33814f8711ad3af4579e5edffb55053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33814f8711ad3af4579e5edffb55053">&#9670;&nbsp;</a></span>static_u32string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#ab33814f8711ad3af4579e5edffb55053">json::static_u32string</a> = typedef <a class="el" href="classjson_1_1basic__static__string.html">basic_static_string</a>&lt;char32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for <a class="el" href="classjson_1_1basic__static__string.html" title="Representation of a constant string that will outlive the json::value that is using it (usually a str...">basic_static_string</a> of char32_t. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8hh_source.html#l00045">45</a> of file <a class="el" href="string__key_8hh_source.html">string_key.hh</a>.</p>

</div>
</div>
<a id="a0f0a239c7b818e7263c9db362d5663a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0a239c7b818e7263c9db362d5663a4">&#9670;&nbsp;</a></span>static_wstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#a0f0a239c7b818e7263c9db362d5663a4">json::static_wstring</a> = typedef <a class="el" href="classjson_1_1basic__static__string.html">basic_static_string</a>&lt;wchar_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for <a class="el" href="classjson_1_1basic__static__string.html" title="Representation of a constant string that will outlive the json::value that is using it (usually a str...">basic_static_string</a> of wchar_t. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8hh_source.html#l00041">41</a> of file <a class="el" href="string__key_8hh_source.html">string_key.hh</a>.</p>

</div>
</div>
<a id="adf4c6d89490ba96079af5596ed4743df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4c6d89490ba96079af5596ed4743df">&#9670;&nbsp;</a></span>string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#adf4c6d89490ba96079af5596ed4743df">json::string</a> = typedef std::basic_string&lt;char, std::char_traits&lt;char&gt;, <a class="el" href="namespacejson.html#ae81c666a2862b007cb033895d0721214">json::allocator</a>&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>String type used by all the json functions and classes. </p>

<p class="definition">Definition at line <a class="el" href="config_8hh_source.html#l00018">18</a> of file <a class="el" href="config_8hh_source.html">config.hh</a>.</p>

</div>
</div>
<a id="a5131b268f0de7a671e4b7a9129f63faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5131b268f0de7a671e4b7a9129f63faf">&#9670;&nbsp;</a></span>string_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#a5131b268f0de7a671e4b7a9129f63faf">json::string_key</a> = typedef <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt;char&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for <a class="el" href="classjson_1_1basic__string__key.html" title="Representation of a string key for an associative container. It&#39;s used as the key of the map in json:...">basic_string_key</a> of chars (the same way <a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaab45cffe084dd3d20d928bee85e7b0f21">std::string</a> is std::basic_string&lt;char&gt;) </p>

<p class="definition">Definition at line <a class="el" href="string__key_8hh_source.html#l00309">309</a> of file <a class="el" href="string__key_8hh_source.html">string_key.hh</a>.</p>

</div>
</div>
<a id="a257983dc753e4e1d0420e71f8b1eab6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257983dc753e4e1d0420e71f8b1eab6d">&#9670;&nbsp;</a></span>u16string_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#a257983dc753e4e1d0420e71f8b1eab6d">json::u16string_key</a> = typedef <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt;char16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for <a class="el" href="classjson_1_1basic__string__key.html" title="Representation of a string key for an associative container. It&#39;s used as the key of the map in json:...">basic_string_key</a> of char16_t. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8hh_source.html#l00313">313</a> of file <a class="el" href="string__key_8hh_source.html">string_key.hh</a>.</p>

</div>
</div>
<a id="a0ea32442a404e94eb5a2ecc3c3b14a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea32442a404e94eb5a2ecc3c3b14a35">&#9670;&nbsp;</a></span>u32string_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#a0ea32442a404e94eb5a2ecc3c3b14a35">json::u32string_key</a> = typedef <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt;char32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for <a class="el" href="classjson_1_1basic__string__key.html" title="Representation of a string key for an associative container. It&#39;s used as the key of the map in json:...">basic_string_key</a> of char32_t. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8hh_source.html#l00315">315</a> of file <a class="el" href="string__key_8hh_source.html">string_key.hh</a>.</p>

</div>
</div>
<a id="ae0da1c79d774841b51e0ad191790344a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0da1c79d774841b51e0ad191790344a">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#ae0da1c79d774841b51e0ad191790344a">json::vector</a> = typedef std::vector&lt;T, <a class="el" href="namespacejson.html#ae81c666a2862b007cb033895d0721214">json::allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector type used by all the json functions and classes. </p>

<p class="definition">Definition at line <a class="el" href="config_8hh_source.html#l00022">22</a> of file <a class="el" href="config_8hh_source.html">config.hh</a>.</p>

</div>
</div>
<a id="a99a4399831ee43095ae3fac2a63acf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a4399831ee43095ae3fac2a63acf57">&#9670;&nbsp;</a></span>wstring_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejson.html#a99a4399831ee43095ae3fac2a63acf57">json::wstring_key</a> = typedef <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt;wchar_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for <a class="el" href="classjson_1_1basic__string__key.html" title="Representation of a string key for an associative container. It&#39;s used as the key of the map in json:...">basic_string_key</a> of wchar_t. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8hh_source.html#l00311">311</a> of file <a class="el" href="string__key_8hh_source.html">string_key.hh</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a42adda0909e4b5681dad640f482f98ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42adda0909e4b5681dad640f482f98ea">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacejson.html#a42adda0909e4b5681dad640f482f98ea">json::value_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum with the possible types a <a class="el" href="classjson_1_1value.html" title="Data structure representing a json value http://www.json.org. ">json::value</a> may hold. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a42adda0909e4b5681dad640f482f98eaa37a6259cc0c1dae299a7866489dff0bd"></a>null&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a42adda0909e4b5681dad640f482f98eaa157db7df530023575515d366c9b672e8"></a>integer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a42adda0909e4b5681dad640f482f98eaa4bca24304861acde5770fdbe3cc2503b"></a>real&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a42adda0909e4b5681dad640f482f98eaa84e2c64f38f78ba3ea5c905ab5a2da27"></a>boolean&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a42adda0909e4b5681dad640f482f98eaab45cffe084dd3d20d928bee85e7b0f21"></a>string&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a42adda0909e4b5681dad640f482f98eaaf1f713c9e000f5d3f280adbd124df4f5"></a>array&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a42adda0909e4b5681dad640f482f98eaaa8cfde6331bd59eb2ac96f8911c4b666"></a>object&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="value_8hh_source.html#l00014">14</a> of file <a class="el" href="value_8hh_source.html">value.hh</a>.</p>
<div class="fragment"><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  {</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <a class="code" href="namespacejson_1_1parser.html#a25424b2064e3b143c94010d65eb2fab9a37a6259cc0c1dae299a7866489dff0bd">null</a>    = 0,</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <a class="code" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaa157db7df530023575515d366c9b672e8">integer</a> = 1,</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <a class="code" href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaa4bca24304861acde5770fdbe3cc2503b">real</a>    = 2,</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="keywordtype">boolean</span> = 3,</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="keywordtype">string</span>  = 4,</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <a class="code" href="namespacejson.html#acbe1e90763ce6266cb4279fcb4264941">array</a>   = 5,</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="keywordtype">object</span>  = 6</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  };</div><div class="ttc" id="namespacejson_html_a42adda0909e4b5681dad640f482f98eaa4bca24304861acde5770fdbe3cc2503b"><div class="ttname"><a href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaa4bca24304861acde5770fdbe3cc2503b">json::value_type::real</a></div></div>
<div class="ttc" id="namespacejson_html_a42adda0909e4b5681dad640f482f98eaa157db7df530023575515d366c9b672e8"><div class="ttname"><a href="namespacejson.html#a42adda0909e4b5681dad640f482f98eaa157db7df530023575515d366c9b672e8">json::value_type::integer</a></div></div>
<div class="ttc" id="namespacejson_html_acbe1e90763ce6266cb4279fcb4264941"><div class="ttname"><a href="namespacejson.html#acbe1e90763ce6266cb4279fcb4264941">json::array</a></div><div class="ttdeci">json::vector&lt; json::value &gt; array</div><div class="ttdoc">Data structure representing a json array. An array is an ordered collection of values. An array begins with [ (left bracket) and ends with ] (right bracket). Values are separated by , (comma). http://www.json.org/. </div><div class="ttdef"><b>Definition:</b> <a href="value_8hh_source.html#l00039">value.hh:39</a></div></div>
<div class="ttc" id="namespacejson_1_1parser_html_a25424b2064e3b143c94010d65eb2fab9a37a6259cc0c1dae299a7866489dff0bd"><div class="ttname"><a href="namespacejson_1_1parser.html#a25424b2064e3b143c94010d65eb2fab9a37a6259cc0c1dae299a7866489dff0bd">json::parser::token_type::null</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2633134121d6757c7ba829d4b2623b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2633134121d6757c7ba829d4b2623b43">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if both strings are not equal. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00517">517</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;  {</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    <span class="keywordflow">return</span> !(a == b);</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a9ce7c064492af9cac758a7b493eea711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce7c064492af9cac758a7b493eea711">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00553">553</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;  {</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;    <span class="keywordflow">return</span> !(a == b);</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a5a8376ba97b28317b7c55fde338ba802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8376ba97b28317b7c55fde338ba802">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator!= </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00589">589</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;  {</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    <span class="keywordflow">return</span> b != a;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="af77baf8a3530de0b7aa88fe4d7b31b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77baf8a3530de0b7aa88fe4d7b31b39">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00625">625</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;  {</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    <span class="keywordflow">return</span> !(a == b);</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="acdafdbde7267785081cb94d7a91857be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdafdbde7267785081cb94d7a91857be">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00661">661</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;  {</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    <span class="keywordflow">return</span> !(a == b);</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a5ca8b4fedc32245aa40ddb63e20e5a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca8b4fedc32245aa40ddb63e20e5a34">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographically compares both strings. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00523">523</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;  {</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    <span class="keywordflow">return</span> std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end(), Traits::lt);</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a466e771d6fe0fbaa01450e34d1a0edab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466e771d6fe0fbaa01450e34d1a0edab">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00559">559</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  {</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    <span class="keywordflow">return</span> Traits::compare(a.c_str(), b, a.size() + 1) &lt; 0;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a1ba51123a1e95f22ab8de9e7196a9d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba51123a1e95f22ab8de9e7196a9d86">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00595">595</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;  {</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="keywordflow">return</span> Traits::compare(a, b.c_str(), b.size() + 1) &lt; 0;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a9c8cbdc279c81e2703c384e4027246c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8cbdc279c81e2703c384e4027246c2">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00631">631</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;  {</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    <span class="keywordflow">return</span> a &lt; b.c_str();</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a7069cd34d18e1a2d66571ce407d86326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7069cd34d18e1a2d66571ce407d86326">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00667">667</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>

<p class="reference">References <a class="el" href="string__key_8inl_source.html#l00197">json::basic_string_key&lt; CharT, Traits, Allocator &gt;::c_str()</a>.</p>
<div class="fragment"><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;  {</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    <span class="keywordflow">return</span> a.c_str() &lt; b;</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a4eace896f7bad716840927c3c6c76d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eace896f7bad716840927c3c6c76d23">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographically compares both strings. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00529">529</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;  {</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;    <span class="keywordflow">return</span> (a == b) || (a &lt; b);</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="ad80aa45d78dfbb09edff5be7544550df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80aa45d78dfbb09edff5be7544550df">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00565">565</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  {</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    <span class="keywordflow">return</span> Traits::compare(a.c_str(), b, a.size() + 1) &lt;= 0;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a8f064054b9f2e109ae5e0c99215b1518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f064054b9f2e109ae5e0c99215b1518">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00601">601</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;  {</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;    <span class="keywordflow">return</span> Traits::compare(a, b.c_str(), b.size() + 1) &lt;= 0;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="acff47dec3ac734cbb37548155dce267c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff47dec3ac734cbb37548155dce267c">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00637">637</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  {</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    <span class="keywordflow">return</span> a &lt;= b.c_str();</div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="af1de63055a07d84c227f7b2867ae8390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1de63055a07d84c227f7b2867ae8390">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00673">673</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>

<p class="reference">References <a class="el" href="string__key_8inl_source.html#l00197">json::basic_string_key&lt; CharT, Traits, Allocator &gt;::c_str()</a>.</p>
<div class="fragment"><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;  {</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;    <span class="keywordflow">return</span> a.c_str() &lt;= b;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a8d76be8d5ff3eca25168c0c80b77ad03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d76be8d5ff3eca25168c0c80b77ad03">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if both strings are equal. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00511">511</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  {</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="keywordflow">return</span> a.size() == b.size() &amp;&amp; std::equal(a.begin(), a.end(), b.begin(), b.end(), Traits::eq);</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="aa2649256bf1d9fb6c15800d4bc70ec70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2649256bf1d9fb6c15800d4bc70ec70">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of comparison operators for c strings. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00547">547</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  {</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    <span class="keywordflow">return</span> Traits::compare(a.c_str(), b, a.size() + 1) == 0;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a0d637420ca495ad7661d973b3515a345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d637420ca495ad7661d973b3515a345">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator== </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00583">583</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  {</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;    <span class="keywordflow">return</span> b == a;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="abc7dc6e54278d38c70f88af57472c439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7dc6e54278d38c70f88af57472c439">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of comparison operators for std::basic_string. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00619">619</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;  {</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    <span class="keywordflow">return</span> a.size() == b.size() &amp;&amp; std::equal(a.begin(), a.end(), b.begin(), b.end());</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="acd8ff35f7fadeee31d3a62608f0fa44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8ff35f7fadeee31d3a62608f0fa44e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00655">655</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;  {</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    <span class="keywordflow">return</span> b == a;</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a85acab7e94d58880b8b93342dc7cea08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85acab7e94d58880b8b93342dc7cea08">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographically compares both strings. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00535">535</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  {</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    <span class="keywordflow">return</span> !(a &lt;= b);</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="acae7459a31f1dfc064e9edbbf01b3db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae7459a31f1dfc064e9edbbf01b3db8">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00571">571</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  {</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;    <span class="keywordflow">return</span> Traits::compare(a.c_str(), b, a.size() + 1) &gt; 0;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a1514e7cdc5f84060c9c6f161eea38589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1514e7cdc5f84060c9c6f161eea38589">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00607">607</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;  {</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;    <span class="keywordflow">return</span> Traits::compare(a, b.c_str(), b.size() + 1) &gt; 0;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="ab67c871179bd20bb8eb2290567f2b9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67c871179bd20bb8eb2290567f2b9c3">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00643">643</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  {</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <span class="keywordflow">return</span> a &gt; b.c_str();</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="afad671d5552c5993ae220e264c32bf51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad671d5552c5993ae220e264c32bf51">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00679">679</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;  {</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    <span class="keywordflow">return</span> a.c_str() &gt; b;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="ad4e232e405cf1f26a8ba37698cda3f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e232e405cf1f26a8ba37698cda3f4c">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lexicographically compares both strings. </p>

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00541">541</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  {</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <span class="keywordflow">return</span> !(a &lt; b);</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a0ca8111d03505de4687d691e75b8b754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca8111d03505de4687d691e75b8b754">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00577">577</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;  {</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;    <span class="keywordflow">return</span> Traits::compare(a.c_str(), b, a.size() + 1) &gt;= 0;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="af011bccfee7064acd948b61ecc40ed73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af011bccfee7064acd948b61ecc40ed73">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const CharT *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00613">613</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;  {</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;    <span class="keywordflow">return</span> Traits::compare(a, b.c_str(), b.size() + 1) &gt;= 0;</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a233436646f22bd9bb8a70b5e37d58b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233436646f22bd9bb8a70b5e37d58b97">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00649">649</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  {</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;    <span class="keywordflow">return</span> a &gt;= b.c_str();</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="af76dbb40389e2ed716138a0d95a65d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76dbb40389e2ed716138a0d95a65d47">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator1 , typename Allocator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool json::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; CharT, Traits, Allocator1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjson_1_1basic__string__key.html">basic_string_key</a>&lt; CharT, Traits, Allocator2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="string__key_8inl_source.html#l00685">685</a> of file <a class="el" href="string__key_8inl_source.html">string_key.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;  {</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;    <span class="keywordflow">return</span> a.c_str() &gt;= b;</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a64bee7abec3a3b5ded49861e3a46068f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bee7abec3a3b5ded49861e3a46068f">&#9670;&nbsp;</a></span>points_inside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool json::points_inside </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if p points to obj or a member of obj True if p points to an address in memory in the range [&amp;obj, (char *)&amp;obj + sizeof(obj)) </p>

<p class="definition">Definition at line <a class="el" href="release_8inl_source.html#l00005">5</a> of file <a class="el" href="release_8inl_source.html">release.inl</a>.</p>

<p class="reference">Referenced by <a class="el" href="string__key_8inl_source.html#l00053">json::basic_string_key&lt; CharT, Traits, Allocator &gt;::basic_string_key()</a>, and <a class="el" href="release_8inl_source.html#l00021">release()</a>.</p>
<div class="fragment"><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> begin = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(&amp;obj);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> end = begin + <span class="keyword">sizeof</span>(T);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> ptr = <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(p);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    <span class="keywordflow">return</span> (ptr &gt;= begin) &amp;&amp; (ptr &lt; end);</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="af777b441b49549f3157150542652538c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af777b441b49549f3157150542652538c">&#9670;&nbsp;</a></span>release() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CharT * json::release </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a string release the ownership over its dynamic memory and return a pointer to it. </p>

<p class="definition">Definition at line <a class="el" href="release_8inl_source.html#l00015">15</a> of file <a class="el" href="release_8inl_source.html">release.inl</a>.</p>

<p class="reference">Referenced by <a class="el" href="string__key_8inl_source.html#l00053">json::basic_string_key&lt; CharT, Traits, Allocator &gt;::basic_string_key()</a>, and <a class="el" href="release_8inl_source.html#l00049">release()</a>.</p>
<div class="fragment"><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacejson.html#af777b441b49549f3157150542652538c">release</a>(std::move(s));</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  }</div><div class="ttc" id="namespacejson_html_af777b441b49549f3157150542652538c"><div class="ttname"><a href="namespacejson.html#af777b441b49549f3157150542652538c">json::release</a></div><div class="ttdeci">CharT * release(std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;s)</div><div class="ttdoc">Makes a string release the ownership over its dynamic memory and return a pointer to it...</div><div class="ttdef"><b>Definition:</b> <a href="release_8inl_source.html#l00015">release.inl:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af8b35a1fdf1bfab72ba0fda7426be30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b35a1fdf1bfab72ba0fda7426be30a">&#9670;&nbsp;</a></span>release() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CharT , typename Traits , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CharT * json::release </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a string release the ownership over its dynamic memory and return a pointer to it. </p>

<p class="definition">Definition at line <a class="el" href="release_8inl_source.html#l00021">21</a> of file <a class="el" href="release_8inl_source.html">release.inl</a>.</p>

<p class="reference">References <a class="el" href="release_8inl_source.html#l00005">points_inside()</a>.</p>
<div class="fragment"><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  {</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <span class="comment">// If the string is a short string, it doesn&#39;t have any dynamic memory so there is no memory to release</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacejson.html#a64bee7abec3a3b5ded49861e3a46068f">points_inside</a>(s.data(), s))</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    {</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;      <span class="comment">// Brief explanation of the dark magics behind this:</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;      <span class="comment">// std::string is encapsulated such that the only way of making it release the ownership of</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;      <span class="comment">// its dynamic memory without deleting it is moving it into another std::string. However, by </span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;      <span class="comment">// doing this the ownership is passed to another std::string so we still have the same problem</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;      <span class="comment">// of the memory being owned by an RAII object that will delete it in its destructor.</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;      <span class="comment">// The solution used below is moving the string into a buffer of bytes using placement new,</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;      <span class="comment">// in order to make the source string release ownership over its memory without passing this</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;      <span class="comment">// ownership to another RAII object, as an array of characters won&#39;t call the destructor of</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;      <span class="comment">// std::string. At this point, the std::string object has released the ownership over its</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;      <span class="comment">// dynamic memory, and the address of this memory can be trivially obtained by calling</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;      <span class="comment">// std::string::data on the buffer.</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;      <span class="keyword">using</span> string_t = std::basic_string&lt;CharT, Traits, Allocator&gt;;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;      <span class="keywordtype">char</span> buffer[<span class="keyword">sizeof</span>(string_t)];</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      ::new (buffer) string_t(std::move(s));</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;      <span class="comment">// std::string::data is const in C++11. Non-const version wasn&#39;t added until C++14</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>CharT *<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span>string_t *<span class="keyword">&gt;</span>(buffer)-&gt;data());</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    }</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  }</div><div class="ttc" id="namespacejson_html_a64bee7abec3a3b5ded49861e3a46068f"><div class="ttname"><a href="namespacejson.html#a64bee7abec3a3b5ded49861e3a46068f">json::points_inside</a></div><div class="ttdeci">bool points_inside(const void *p, const T &amp;obj)</div><div class="ttdoc">True if p points to obj or a member of obj True if p points to an address in memory in the range [&amp;ob...</div><div class="ttdef"><b>Definition:</b> <a href="release_8inl_source.html#l00005">release.inl:5</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abb4e742101a86b07cf0cd06570a8a3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4e742101a86b07cf0cd06570a8a3df">&#9670;&nbsp;</a></span>release() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * json::release </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a vector release the ownership over its dynamic memory and return a pointer to it. </p>

<p class="definition">Definition at line <a class="el" href="release_8inl_source.html#l00049">49</a> of file <a class="el" href="release_8inl_source.html">release.inl</a>.</p>

<p class="reference">References <a class="el" href="release_8inl_source.html#l00015">release()</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  {</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacejson.html#af777b441b49549f3157150542652538c">release</a>(std::move(v));</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  }</div><div class="ttc" id="namespacejson_html_af777b441b49549f3157150542652538c"><div class="ttname"><a href="namespacejson.html#af777b441b49549f3157150542652538c">json::release</a></div><div class="ttdeci">CharT * release(std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;s)</div><div class="ttdoc">Makes a string release the ownership over its dynamic memory and return a pointer to it...</div><div class="ttdef"><b>Definition:</b> <a href="release_8inl_source.html#l00015">release.inl:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ed064e51967e385b995309e2b1e7dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed064e51967e385b995309e2b1e7dbf">&#9670;&nbsp;</a></span>release() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * json::release </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a vector release the ownership over its dynamic memory and return a pointer to it. </p>

<p class="definition">Definition at line <a class="el" href="release_8inl_source.html#l00055">55</a> of file <a class="el" href="release_8inl_source.html">release.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  {</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keyword">using</span> vector_t = std::vector&lt;T, Allocator&gt;;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordtype">char</span> buffer[<span class="keyword">sizeof</span>(vector_t)];</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    ::new (buffer) vector_t(std::move(v));</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>vector_t *<span class="keyword">&gt;</span>(buffer)-&gt;data();</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
<a id="a35a78b4c5e0c268070e8572e13e045a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a78b4c5e0c268070e8572e13e045a0">&#9670;&nbsp;</a></span>release() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Deleter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; T, Deleter &gt;::pointer json::release </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T, Deleter &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a unique_ptr release the ownership over its dynamic memory. Same as <a class="el" href="namespacejson.html#a30c670fcc57b21f3b9485ec457145015" title="Makes a unique_ptr release the ownership over its dynamic memory. Same as p.release() ...">p.release()</a> </p>

<p class="definition">Definition at line <a class="el" href="release_8inl_source.html#l00064">64</a> of file <a class="el" href="release_8inl_source.html">release.inl</a>.</p>

<p class="reference">References <a class="el" href="release_8inl_source.html#l00015">release()</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  {</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacejson.html#af777b441b49549f3157150542652538c">release</a>(std::move(p));</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  }</div><div class="ttc" id="namespacejson_html_af777b441b49549f3157150542652538c"><div class="ttname"><a href="namespacejson.html#af777b441b49549f3157150542652538c">json::release</a></div><div class="ttdeci">CharT * release(std::basic_string&lt; CharT, Traits, Allocator &gt; &amp;s)</div><div class="ttdoc">Makes a string release the ownership over its dynamic memory and return a pointer to it...</div><div class="ttdef"><b>Definition:</b> <a href="release_8inl_source.html#l00015">release.inl:15</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a30c670fcc57b21f3b9485ec457145015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c670fcc57b21f3b9485ec457145015">&#9670;&nbsp;</a></span>release() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Deleter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; T, Deleter &gt;::pointer json::release </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T, Deleter &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a unique_ptr release the ownership over its dynamic memory. Same as <a class="el" href="namespacejson.html#a30c670fcc57b21f3b9485ec457145015" title="Makes a unique_ptr release the ownership over its dynamic memory. Same as p.release() ...">p.release()</a> </p>

<p class="definition">Definition at line <a class="el" href="release_8inl_source.html#l00070">70</a> of file <a class="el" href="release_8inl_source.html">release.inl</a>.</p>
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  {</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keywordflow">return</span> p.release();</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  }</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacejson.html">json</a></li>
    <li class="footer">Generated on Sun Oct 29 2017 12:58:08 for Json by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
